ci_cd = [
    # ---------------------- Difficulty 1 ----------------------
    {
        "category": "ci-cd",
        "term": "What is Continuous Integration?",
        "difficulty": 1,
        "formal_definition": "Continuous Integration (CI) is the practice of frequently merging code changes into a shared repository and automatically building and testing them.",
        "simple_definition": "Developers push code often, and automated tests run to detect issues early.",
        "example": "A GitHub Actions workflow running tests on every pull request.",
        "why_it_matters": "CI catches bugs early and ensures code stays stable as teams scale."
    },
    {
        "category": "ci-cd",
        "term": "What is Continuous Delivery?",
        "difficulty": 1,
        "formal_definition": "Continuous Delivery ensures that code is always in a deployable state by automating build, test, and packaging steps.",
        "simple_definition": "Automatically prepares every change so it could be deployed at any time.",
        "example": "Automatically building a Docker image and pushing it to ECR after tests pass.",
        "why_it_matters": "Prevents last-minute release chaos and increases deployment confidence."
    },
    {
        "category": "ci-cd",
        "term": "What is Continuous Deployment?",
        "difficulty": 1,
        "formal_definition": "Continuous Deployment automatically deploys every validated change to production without manual approval.",
        "simple_definition": "Every code change that passes tests gets deployed automatically.",
        "example": "A commit to main triggers tests → build → deploy to production via GitHub Actions.",
        "why_it_matters": "Eliminates human bottlenecks and allows ultra-fast iteration."
    },

    # ---------------------- Difficulty 2 ----------------------
    {
        "category": "ci-cd",
        "term": "What is a CI/CD pipeline?",
        "difficulty": 2,
        "formal_definition": "A CI/CD pipeline is an automated workflow that builds, tests, and deploys software.",
        "simple_definition": "A set of automated steps to build, test, and deploy code.",
        "example": "Pipeline: lint → unit tests → integration tests → build → deploy.",
        "why_it_matters": "Pipelines enforce consistency and remove manual deployment risks."
    },
    {
        "category": "ci-cd",
        "term": "What is a rolling deployment?",
        "difficulty": 2,
        "formal_definition": "A rolling deployment gradually replaces old application instances with new ones without downtime.",
        "simple_definition": "Update servers one at a time with no downtime.",
        "example": "Kubernetes rolling update replacing pods gradually.",
        "why_it_matters": "Minimizes risk by avoiding full system downtime."
    },
    {
        "category": "ci-cd",
        "term": "What is a canary deployment?",
        "difficulty": 2,
        "formal_definition": "A canary deployment releases new software to a small subset of users before full rollout.",
        "simple_definition": "Deploy new code to a few users first to test safety.",
        "example": "1% of traffic routed to the new version, 99% to the old one.",
        "why_it_matters": "Catches bugs early without impacting most users."
    },

    # ---------------------- Difficulty 3 ----------------------
    {
        "category": "ci-cd",
        "term": "What is a blue–green deployment?",
        "difficulty": 3,
        "formal_definition": "Blue–green deployment uses two identical environments (blue and green). One serves production while the other hosts the new release. Traffic switches only when the new version is stable.",
        "simple_definition": "Two environments: one live, one updated. Switch traffic when ready.",
        "example": "ALB switching from blue EC2 fleet to green EC2 fleet instantly.",
        "why_it_matters": "Enables zero-downtime deployments and instant rollbacks."
    },
    {
        "category": "ci-cd",
        "term": "What is an artifact?",
        "difficulty": 3,
        "formal_definition": "An artifact is a compiled or packaged output generated by CI pipelines, such as Docker images, .zip files, binaries, or wheels.",
        "simple_definition": "The final product your CI pipeline produces.",
        "example": "A Docker image pushed to Docker Hub after build completion.",
        "why_it_matters": "Artifacts are reused in deployment for consistency and reproducibility."
    },
    {
        "category": "ci-cd",
        "term": "What is infrastructure as code in CI/CD?",
        "difficulty": 3,
        "formal_definition": "Infrastructure as Code (IaC) stores provisioning configurations in code, which CI/CD pipelines can validate, test, and deploy automatically.",
        "simple_definition": "Defining servers and cloud resources in code that pipelines can deploy.",
        "example": "Terraform plan + apply running via GitHub Actions.",
        "why_it_matters": "Automates cloud management and guarantees consistent environments."
    },

    # ---------------------- Difficulty 4 ----------------------
    {
        "category": "ci-cd",
        "term": "How do you secure a CI/CD pipeline?",
        "difficulty": 4,
        "formal_definition": "Securing CI/CD includes: rotating secrets, scanning dependencies, restricting runner permissions, isolating build agents, and enforcing signing/verification of builds.",
        "simple_definition": "Protect secrets, restrict permissions, scan code, and verify builds.",
        "example": "Using GitHub OIDC + AWS IAM instead of long-lived AWS access keys.",
        "why_it_matters": "CI/CD is a high-value target; breaches can compromise entire systems."
    },
    {
        "category": "ci-cd",
        "term": "How do you design a CI/CD workflow for microservices?",
        "difficulty": 4,
        "formal_definition": "Each microservice should have its own CI pipeline, automated tests, independent deployments, versioning, and image tagging strategy while sharing cross-service integration tests.",
        "simple_definition": "Each microservice gets its own independent pipeline and deployment.",
        "example": "Service A runs its own GitHub Actions pipeline, pushing its own Docker image.",
        "why_it_matters": "Microservices break monoliths into scalable, independently deployable units."
    },
    {
        "category": "ci-cd",
        "term": "How do you automate rollback in CI/CD?",
        "difficulty": 4,
        "formal_definition": "Automatic rollbacks occur when health checks fail, metrics degrade, or monitoring detects errors. Systems revert to the last known good deployment.",
        "simple_definition": "If the new version fails, the system switches back automatically.",
        "example": "Kubernetes rolling update reverting after liveness probe failures.",
        "why_it_matters": "Automatic rollback prevents outages in production deployments."
    }
]
